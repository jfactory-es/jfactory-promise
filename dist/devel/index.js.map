{"version":3,"file":"index.js","sources":["../../node_modules/jfactory-es/src/jFactory-env.mjs","../../node_modules/jfactory-es/src/jFactory-helpers.mjs","../../node_modules/jfactory-es/src/jFactory-loader.mjs","../../node_modules/jfactory-es/src/JFactoryTrace.mjs","../../node_modules/jfactory-es/src/JFactoryError.mjs","../../node_modules/jfactory-es/src/JFactoryExpect.mjs","../../node_modules/jfactory-es/src/JFactoryPromise.mjs"],"sourcesContent":["/*!\n * jFactory, Copyright (c) 2019, Stéphane Plazis\n * https://github.com/jfactory-es/jfactory/blob/master/LICENSE.txt\n */\n\n// ---------------------------------------------------------------------------------------------------------------------\n// jFactory Env\n// ---------------------------------------------------------------------------------------------------------------------\n\n// Compile-time immutable Env; used by Tree Shaking to remove unused code\nexport const JFACTORY_DEV = typeof COMPILER_DEV === \"undefined\" ? false : COMPILER_DEV; // Developer Mode\nexport const JFACTORY_DEBUG = typeof COMPILER_DEBUG === \"undefined\" ? false : COMPILER_DEBUG; // Debug the library\nexport const JFACTORY_CLI = typeof COMPILER_CLI === \"undefined\" ?\n    typeof process !== \"undefined\" && process.versions && process.versions.node : COMPILER_CLI;\n\n// Mutable configuration\nexport const jFactoryConfig = {\n    TraitLog: JFACTORY_DEV && !JFACTORY_CLI || JFACTORY_DEBUG,\n    JFactoryError: {\n        keys: [\"$.about.name\", \"$dev_name\", \"$name\", \"name\", \"id\"]\n    },\n    JFactoryTrace: JFACTORY_DEV && !JFACTORY_CLI\n        && {\n            keys: [\"$dev_traceLog\", \"$dev_traceSource\"],\n            libOptions: {\n                offline: Boolean(globalThis.chrome), // loading sourcemaps is not required in chrome\n                filter: function(value) {\n                    return value.lineNumber\n                    // && (value.fileName + value.functionName).toLocaleLowerCase().indexOf('jfactory') < 0\n                }\n            }\n        },\n    jFactoryDev: JFACTORY_DEV\n        && {\n            requireCompatibility: {\n                globalThis: {\n                    test: () => globalThis,\n                    info: \"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/globalThis\"\n                },\n                fetch: {\n                    test: () => fetch,\n                    info: \"https://developer.mozilla.org/docs/Web/API/Fetch_API/Using_Fetch\"\n                },\n                Request: {\n                    test: () => Request,\n                    info: \"https://developer.mozilla.org/docs/Web/API/Request\"\n                },\n                \"AbortController, AbortSignal\": {\n                    test: () => new AbortController().signal,\n                    info: \"https://developer.mozilla.org/docs/Web/API/AbortController, \" +\n                        \"https://developer.mozilla.org/docs/Web/API/AbortSignal\"\n                },\n                MutationObserver: {\n                    test: () => MutationObserver,\n                    info: \"https://developer.mozilla.org/docs/Web/API/MutationObserver\"\n                }\n            }\n        }\n};","/* jFactory, Copyright (c) 2019, Stéphane Plazis, https://github.com/jfactory-es/jfactory/blob/master/LICENSE.txt */\n\nimport _ from \"lodash\";\nimport $ from \"jquery\";\n\n// ---------------------------------------------------------------------------------------------------------------------\n// jFactory Helpers\n// ---------------------------------------------------------------------------------------------------------------------\n// Centralize helpers and externals in one module\n// ---------------------------------------------------------------------------------------------------------------------\n// The jFactory bundler should exclude external imports to let the project deals with external libraries,\n// allowing customized imports (CDN scripts, optimized compiled imports, overrides...)\n// See: rollup: \"output.globals\" and \"external\"; webpack: \"externals\"\n// ---------------------------------------------------------------------------------------------------------------------\n// Status: Beta\n// ---------------------------------------------------------------------------------------------------------------------\n\nexport const jQuery = $;\n\nexport const helper_isNative = _.isNative;\nexport const helper_isString = _.isString;\nexport const helper_isNumber = _.isNumber;\nexport const helper_isPlainObject = _.isPlainObject;\nexport const helper_defaultsDeep = _.defaultsDeep;\nexport const helper_lowerFirst = _.lowerFirst;\nexport const helper_get = _.get;\nexport const helper_template = _.template;\nexport const helper_camelCase = _.camelCase;\n\nexport const NOOP = () => {};\nexport const setFunctionName = (name, f) => Object.defineProperty(f, \"name\", { value: name });","/* jFactory, Copyright (c) 2019, Stéphane Plazis, https://github.com/jfactory-es/jfactory/blob/master/LICENSE.txt */\n\nimport { JFACTORY_CLI, JFACTORY_DEV, jFactoryConfig } from \"./jFactory-env\";\n\n// ---------------------------------------------------------------------------------------------------------------------\n// jFactory Loader\n// ---------------------------------------------------------------------------------------------------------------------\n// Status: Beta\n// ---------------------------------------------------------------------------------------------------------------------\n\nexport const jFactoryLoader = {\n    seq: [],\n    init() {\n        if (this.seq) {\n            let seq = this.seq;\n            delete this.seq;\n            for (let module of seq) {\n                module()\n            }\n            delete globalThis.jFactoryOverride\n        }\n    },\n    onInit(handler) {\n        this.seq.push(handler)\n    }\n};\n\nexport function jFactoryDev() {\n    console.warn(\"jFactory: RUNNING IN DEVELOPER MODE, PERFORMANCES WILL BE AFFECTED\");\n    for (let [name, entry] of Object.entries(jFactoryConfig.jFactoryDev.requireCompatibility)) {\n        let pass;\n        try {pass = Boolean(entry.test())} catch (ignore) {}\n        if (!pass) {\n            console.warn(`jFactory may require the support of \"${name}\", ${entry.info}`)\n        }\n    }\n}\n\nexport function jFactoryInit() {\n    !jFactoryConfig.TraitLog && (JFACTORY_DEV || JFACTORY_CLI) && console.warn(\"jFactory: LOGS REMOVED\");\n}\n\nJFACTORY_DEV && jFactoryLoader.onInit(jFactoryDev);\njFactoryLoader.onInit(jFactoryInit);","/* jFactory, Copyright (c) 2019, Stéphane Plazis, https://github.com/jfactory-es/jfactory/blob/master/LICENSE.txt */\n\nimport { JFACTORY_DEV, jFactoryConfig } from \"./jFactory-env\";\nimport { jFactoryLoader } from \"./jFactory-loader\";\nimport { NOOP } from \"./jFactory-helpers\";\n\n// ---------------------------------------------------------------------------------------------------------------------\n// JFactoryTrace\n// ---------------------------------------------------------------------------------------------------------------------\n// Status: Beta\n// ---------------------------------------------------------------------------------------------------------------------\n// - #limitation# Error.stack is not standardized\n// - #limitation# Error.stack is not source-mapped\n// - #limitation# bug https://bugzilla.mozilla.org/show_bug.cgi?id=1584244\n// - #limitation# StackTrace.js resolves sourcemaps. Unfortunately, it doesn't work with \"webpack:\" protocol\n//   see https://github.com/stacktracejs/stacktrace.js/issues/209\n// ---------------------------------------------------------------------------------------------------------------------\n// https://github.com/mozilla/source-map/\n// https://www.stacktracejs.com/\n// https://github.com/novocaine/sourcemapped-stacktrace\n// ---------------------------------------------------------------------------------------------------------------------\n\nexport class JFactoryTrace_NOFILTER {\n\n    constructor({ label, stackTraceLimit, keys, libOptions } = {}) {\n        this.label = label || \"The stack has been printed in the console\";\n        this.stackTraceLimit = stackTraceLimit || Infinity;\n        this.keys = keys || [\"stackLog\", \"stackSource\"];\n        this.libOptions = libOptions || {}\n    }\n\n    captureTraceSource(omitAboveFunctionName, omitSelf) {\n        let _stackTraceLimit;\n        if (this.stackTraceLimit) {\n            _stackTraceLimit = Error.stackTraceLimit;\n            Error.stackTraceLimit = this.stackTraceLimit\n        }\n        if (!omitAboveFunctionName) {\n            omitAboveFunctionName = \"captureTraceSource\";\n            omitSelf = true\n        }\n        let traceSource = {\n            source: new Error(),\n            omitAboveFunctionName,\n            omitSelf\n        };\n        if (this.stackTraceLimit) {\n            Error.stackTraceLimit = _stackTraceLimit\n        }\n        return traceSource\n    }\n\n    attachTrace(targetObject, traceSource) {\n        if (typeof traceSource !== \"object\") {\n            traceSource = this.captureTraceSource(traceSource || \"attachTrace\", !traceSource);\n        }\n\n        let trace = traceSource.source;\n        this.toPrintableTrace(traceSource)\n            .then(r => trace = r);\n\n        let log = () => console.log(trace) || this.label;\n\n        Object.defineProperty(targetObject, this.keys[0] /* traceLog */, {\n            enumerable: false,\n            configurable: true,\n            // hide the function body to improve readability in devtool\n            get: () => log()\n        });\n        Object.defineProperty(targetObject, this.keys[1] /* traceSource */, {\n            enumerable: false,\n            configurable: true,\n            // hide the traceSource Error to improve readability in devtool, specially in Firefox\n            get: () => traceSource\n        });\n    }\n\n    toPrintableTrace(traceSource) {\n        // SPEC: this overridable method returns a promise\n        // because stacktrace parsers may be asynchronous\n        return Promise.resolve(traceSource.source)\n    }\n}\n\nexport class JFactoryTrace_LIB_STACKTRACE extends JFactoryTrace_NOFILTER {\n\n    constructor(config) {\n        super(config);\n    }\n\n    toPrintableTrace(traceSource) {\n        return StackTrace.fromError(traceSource.source, this.libOptions)\n            .then(traceFrames => {\n\n                if (traceSource.omitAboveFunctionName) {\n                    let slice = traceFrames.findIndex(\n                        value => {\n                            return value.functionName && value.functionName.endsWith(traceSource.omitAboveFunctionName)\n                        }\n                    );\n                    if (slice > 0) {\n                        if (traceSource.omitSelf) {\n                            slice++\n                        }\n                        traceFrames = traceFrames.slice(slice);\n                    }\n                }\n                traceFrames = traceFrames\n                    .filter(this.libOptions.filter);\n                return this.formatTraceFrames(traceFrames)\n            });\n    }\n\n    formatTraceFrames(traceFrames) {\n        let header;\n        let linePrefix;\n        if (this.libOptions.offline && window.chrome) {\n            // if the fallowing syntax is detected on Chrome,\n            // the console.log() will convert the fileNames using sourcemaps\n            header = \"Error\\n\"; // notes that anything after \"Error\" is valid\n            linePrefix = \"\\tat \";\n        } else {\n            header = \"\";\n            linePrefix = \"\";\n        }\n        return header +\n            traceFrames\n                .map(sf => linePrefix + sf.toString())\n                .join(\"\\n\");\n    }\n}\n\n// ---------------------------------------------------------------------------------------------------------------------\n// jFactoryTrace\n// ---------------------------------------------------------------------------------------------------------------------\n// Status: Beta\n// ---------------------------------------------------------------------------------------------------------------------\n\nexport const jFactoryTrace = {};\n\njFactoryLoader.onInit(function() {\n    let config = jFactoryConfig.JFactoryTrace;\n    if (config && config.use !== false) {\n        let constructor;\n        constructor = typeof config.use === \"function\" ?\n            config.use : typeof StackTrace === \"object\" ?\n                JFactoryTrace_LIB_STACKTRACE :\n                (JFACTORY_DEV && console.warn(\"jFactory: StackTrace lib not found, using fallback\"),\n                JFactoryTrace_NOFILTER);\n        if (constructor === JFactoryTrace_LIB_STACKTRACE) {\n            console.warn(\"jFactory: Stack trace enabled; Performance will be affected\")\n        }\n        jFactoryTrace.tracer = new constructor(config);\n    } else {\n        jFactoryTrace.tracer = {\n            captureTraceSource: NOOP,\n            attachTrace: NOOP\n        };\n    }\n});","/* jFactory, Copyright (c) 2019, Stéphane Plazis, https://github.com/jfactory-es/jfactory/blob/master/LICENSE.txt */\n\nimport { JFACTORY_DEV, jFactoryConfig } from \"./jFactory-env\";\nimport { helper_get, helper_isNative, helper_lowerFirst, helper_template } from \"./jFactory-helpers\";\nimport { jFactoryTrace } from \"./JFactoryTrace\";\n\n// ---------------------------------------------------------------------------------------------------------------------\n// JFactoryError\n// ---------------------------------------------------------------------------------------------------------------------\n// Status: Beta\n// ---------------------------------------------------------------------------------------------------------------------\n\nexport class JFactoryError extends Error {\n    constructor(message = \"unspecified error\", data = null) {\n        data = Object.assign(Object.create(null), data);\n        message = JFactoryError.toPrintable(message, data);\n        super(message);\n        this.$data = Object.assign(Object.create(null), data);\n    }\n\n    toString() {\n        return this.message\n    }\n\n    * [Symbol.iterator]() {\n        yield this.message;\n        yield this.$data;\n    }\n\n    static getId(object) {\n        return object[(jFactoryConfig.JFactoryError.keys || JFactoryError.DEFAULT_KEYS).find(key => {\n            let val = helper_get(object, key);\n            return val || val === 0\n        })]\n    }\n\n    static toPrintableData(data) {\n        const templateData = {};\n        let nv;\n        for (let [key, val] of Object.entries(data)) {\n            switch (typeof val) {\n                case \"function\":\n                    val = val.name + \"()\";\n                    break;\n                case \"object\":\n                    if (val === null) {\n                        val = \"null\";\n                        break\n                    }\n                    if (val instanceof Error) {\n                        val = val.toString();\n                        break\n                    }\n                    if ((nv = JFactoryError.getId(val)) !== undefined) {\n                        val = '\"' + nv + '\"'\n                    } else {\n                        if (!helper_isNative(val.toString)) {\n                            val = val.toString()\n                        } else {\n                            try {\n                                nv = JSON.stringify(val);\n                                val = nv.length > JFactoryError.JSON_MAX\n                                    ? nv.substring(0, JFactoryError.JSON_MAX) + \"[...]\" : nv;\n                            } catch (e) {\n                                val = \"[object \" + val.constructor.name + \"]\"\n                            }\n                        }\n                    }\n                    break;\n                case \"string\":\n                    val = '\"' + val + '\"';\n                    break;\n                default:\n                    val = String(val)\n            }\n            templateData[key] = val\n        }\n        return templateData\n    }\n\n    static toPrintable(template, data) {\n        const templateMessage = [];\n        for (let part of template.split(\";\")) {\n            let placeholder;\n            let RE_PLACEHOLDER = JFactoryError.RE_PLACEHOLDER;\n            RE_PLACEHOLDER.lastIndex = 0;\n            if ((placeholder = RE_PLACEHOLDER.exec(part))) {\n                do {\n                    if (placeholder[1] && placeholder[1] in data) {\n                        templateMessage.push(part.trim());\n                        break\n                    }\n                } while ((placeholder = RE_PLACEHOLDER.exec(part)) !== null)\n            } else {\n                templateMessage.push(part.trim());\n            }\n        }\n        return helper_lowerFirst(helper_template(templateMessage.join(\"; \"))(JFactoryError.toPrintableData(data)));\n    }\n}\n\nJFactoryError.JSON_MAX = 40;\nJFactoryError.DEFAULT_KEYS = [\"name\", \"id\"];\nJFactoryError.RE_PLACEHOLDER = /\\${([^}]+)}/g;\n\n// ---------------------------------------------------------------------------------------------------------------------\n// jFactoryError\n// ---------------------------------------------------------------------------------------------------------------------\n// Status: Beta\n// ---------------------------------------------------------------------------------------------------------------------\n\nexport let jFactoryError = new Proxy(JFactoryError, {\n    set: function(target, property, value) {\n        let { template } = value;\n\n        if (JFACTORY_DEV && target[property]) {\n            throw new Error(\"already declared\");\n        }\n\n        target[property] = class extends JFactoryError {\n            constructor(data, traceSource) {\n                super(template, data);\n                jFactoryTrace.tracer.attachTrace(this.$data, traceSource);\n            }\n        };\n        // Caution: Chrome automatically resolves sourcemap when logging errors\n        // but only if the error name starts with \"Error\"\n        target[property].prototype.name = \"Error jFactoryError.\" + property;\n\n        return true\n    }\n});\n\njFactoryError.INVALID_VALUE = { template: \"invalid value for ${target}; Reason: ${reason}; Given: ${given}\" };\njFactoryError.INVALID_CALL = { template: \"invalid call ${target}; Reason: ${reason}; Owner: ${owner}\" };\njFactoryError.PROMISE_EXPIRED = { template: \"expired promise ${target}; Reason: ${reason}\" };\njFactoryError.REQUEST_ERROR = { template: \"error requesting ${target}; Reason: ${reason}; Owner: ${owner}\" };\njFactoryError.KEY_DUPLICATED = { template: \"duplicated key for ${target}; Given: ${given}\" };\njFactoryError.KEY_MISSING = { template: \"missing key for ${target}; Given: ${given}\" };","/* jFactory, Copyright (c) 2019, Stéphane Plazis, https://github.com/jfactory-es/jfactory/blob/master/LICENSE.txt */\n\nimport { jFactoryError } from \"./JFactoryError\";\nimport { helper_isNumber, helper_isPlainObject, helper_isString } from \"./jFactory-helpers\";\nimport { jFactoryLoader } from \"./jFactory-loader\";\n\n// ---------------------------------------------------------------------------------------------------------------------\n// JFactoryExpect\n// ---------------------------------------------------------------------------------------------------------------------\n// A small input/output validation tool\n// ---------------------------------------------------------------------------------------------------------------------\n// Status: Alpha, Draft\n// ---------------------------------------------------------------------------------------------------------------------\n\n/**\n * @return {*|JFactoryExpect}\n */\nexport function JFactoryExpect(label, value) {\n    if (new.target) {\n        this.label = label;\n        this.value = value;\n    } else {\n        return new JFactoryExpect(label, value)\n    }\n}\n\nconst error = function jFactoryThrow(label, value, message) {\n    throw new jFactoryError.INVALID_VALUE({\n        target: label,\n        reason: message,\n        given: value\n    })\n};\n\nconst staticMethods = {\n    /**\n     * @method notUndefined\n     * @memberOf JFactoryExpect#\n     * @return JFactoryExpect\n     */\n    /**\n     * @method notUndefined\n     * @memberOf JFactoryExpect\n     */\n    notUndefined(label, value) {\n        if (value === undefined) {\n            error(label, value, \"cannot be undefined\")\n        }\n        return true\n    },\n\n    /**\n     * @method notEmptyString\n     * @memberOf JFactoryExpect#\n     * @return JFactoryExpect\n     */\n    /**\n     * @method notEmptyString\n     * @memberOf JFactoryExpect\n     */\n    notEmptyString(label, value) {\n        if (value === \"\") {\n            error(label, value, \"cannot be empty string\")\n        }\n        return true\n    },\n\n    /**\n     * @method notFalsy\n     * @memberOf JFactoryExpect#\n     * @return JFactoryExpect\n     */\n    /**\n     * @method notFalsy\n     * @memberOf JFactoryExpect\n     */\n    notFalsy(label, value) {\n        if (!value) {\n            error(label, value, 'cannot be a falsy value (undefined, null, NaN, 0, \"\")')\n        }\n        return true\n    },\n\n    /**\n     * @method validSpaces\n     * @memberOf JFactoryExpect#\n     * @return JFactoryExpect\n     */\n    /**\n     * @method validSpaces\n     * @memberOf JFactoryExpect\n     */\n    validSpaces(label, value) {\n        if (!value.replace || value.replace(/\\s+/g, \" \").trim() !== value) {\n            error(label, value, \"invalid space delimiters\")\n        }\n        return true\n    },\n\n    /**\n     * @method matchReg\n     * @memberOf JFactoryExpect#\n     * @param {RegExp} reg\n     * @return JFactoryExpect\n     */\n    /**\n     * @method matchReg\n     * @memberOf JFactoryExpect\n     */\n    matchReg(label, value, reg) {\n        if (!reg.test(value)) {\n            error(label, value, 'string \"' + value + '\" must match ' + reg)\n        }\n        return true\n    },\n\n    /**\n     * @method type\n     * @memberOf JFactoryExpect#\n     * @param {...*} expected\n     * @return JFactoryExpect\n     */\n    /**\n     * @method type\n     * @memberOf JFactoryExpect\n     */\n    type(label, value, ...expected) {\n        let name, ok = false;\n        for (let constructor of expected) {\n            if (constructor === null) {\n                name = \"Null\"\n            } else if (\"name\" in constructor) {\n                name = constructor.name\n            }\n            let test = staticMethods[\"type\" + name];\n            if (test) {\n                try {ok = test(label, value/*, e*/)} catch (e) {}\n            } else {\n                ok = value instanceof constructor\n            }\n            if (ok) break\n        }\n        if (!ok) {\n            error(label, value, \"must be an instance of [\" + expected.map(e => e.name).join(\", \") + \"]\")\n        }\n        return true\n    },\n\n    /**\n     * @method typeNull\n     * @memberOf JFactoryExpect#\n     * @return JFactoryExpect\n     */\n    /**\n     * @method typeNull\n     * @memberOf JFactoryExpect\n     */\n    typeNull(label, value) {\n        if (value !== null) {\n            error(label, value, \"must be null\")\n        }\n        return true\n    },\n\n    /**\n     * @method typeBoolean\n     * @memberOf JFactoryExpect#\n     * @return JFactoryExpect\n     */\n    /**\n     * @method typeBoolean\n     * @memberOf JFactoryExpect\n     */\n    typeBoolean(label, value) {\n        if (value !== true && value !== false) {\n            error(label, value, \"must be a boolean\")\n        }\n        return true\n    },\n\n    /**\n     * @method typeString\n     * @memberOf JFactoryExpect#\n     * @return JFactoryExpect\n     */\n    /**\n     * @method typeString\n     * @memberOf JFactoryExpect\n     */\n    typeString(label, value) {\n        if (!helper_isString(value)) {\n            error(label, value, \"must be a string\")\n        }\n        return true\n    },\n\n    /**\n     * @method typeNumber\n     * @memberOf JFactoryExpect#\n     * @return JFactoryExpect\n     */\n    /**\n     * @method typeNumber\n     * @memberOf JFactoryExpect\n     */\n    typeNumber(label, value) {\n        if (!helper_isNumber(value)) {\n            error(label, value, \"must be a number\")\n        }\n        return true\n    },\n\n    /**\n     * @method typeFunction\n     * @memberOf JFactoryExpect#\n     * @return JFactoryExpect\n     */\n    /**\n     * @method typeFunction\n     * @memberOf JFactoryExpect\n     */\n    typeFunction(label, value) {\n        if (!(typeof value === \"function\")) {\n            error(label, value, \"must be a function\")\n        }\n        return true\n    },\n\n    /**\n     * @method typePlainObject\n     * @memberOf JFactoryExpect#\n     * @return JFactoryExpect\n     */\n    /**\n     * @method typePlainObject\n     * @memberOf JFactoryExpect\n     */\n    typePlainObject(label, value) {\n        if (!helper_isPlainObject(value)) {\n            error(label, value, \"must be a plain object\")\n        }\n        return true\n    },\n\n    /**\n     * @method equal\n     * @memberOf JFactoryExpect#\n     * @param {*} expected\n     * @return JFactoryExpect\n     */\n    /**\n     * @method equal\n     * @memberOf JFactoryExpect\n     */\n    equal(label, value, ...expected) {\n        let ok = false;\n        for (let e of expected) {\n            if ((ok = value === e)) break\n        }\n        if (!ok) {\n            error(label, value, \"must be one of [\" + expected + \"]\")\n        }\n        return true;\n    },\n\n    /**\n     * @method equalIn\n     * @memberOf JFactoryExpect#\n     * @param {Array|Object} expected\n     * @return JFactoryExpect\n     */\n    /**\n     * @method equalIn\n     * @memberOf JFactoryExpect\n     */\n    equalIn(label, value, expected) {\n        if (!Array.isArray(expected)) {\n            expected = Object.values(expected)\n        }\n        if (!expected.includes(value)) {\n            error(label, value, \"must be one from [\" + expected.join(\", \") + \"]\")\n        }\n        return true\n    },\n\n    /**\n     * @method properties\n     * @memberOf JFactoryExpect#\n     * @param {Array} expected\n     * @return JFactoryExpect\n     */\n    /**\n     * @method properties\n     * @memberOf JFactoryExpect\n     */\n    properties(label, value, expected) {\n        for (let name of Object.getOwnPropertyNames(value)) {\n            JFactoryExpect(label + ', property name \"' + name + '\"', name).equalIn(expected)\n        }\n        return true\n    },\n\n    /**\n     * @method writable\n     * @memberOf JFactoryExpect#\n     * @param {String} key\n     * @return JFactoryExpect\n     */\n    /**\n     * @method writable\n     * @memberOf JFactoryExpect\n     */\n    writable(label, value, key) {\n        if (!Object.getOwnPropertyDescriptor(value, key).writable) {\n            error(label, value, \"must be writable\")\n        }\n        return true\n    },\n\n    /**\n     * @method notWritable\n     * @memberOf JFactoryExpect#\n     * @param {String} key\n     * @return JFactoryExpect\n     */\n    /**\n     * @method notWritable\n     * @memberOf JFactoryExpect\n     */\n    notWritable(label, value, key) {\n        if (Object.getOwnPropertyDescriptor(value, key).writable) {\n            error(label, value, \"must not be writable\")\n        }\n        return true\n    },\n\n    /**\n     * @method enumerable\n     * @memberOf JFactoryExpect#\n     * @param {String} key\n     * @return JFactoryExpect\n     */\n    /**\n     * @method enumerable\n     * @memberOf JFactoryExpect\n     */\n    enumerable(label, value, key) {\n        if (!Object.prototype.propertyIsEnumerable.call(value, key)) {\n            error(label, value, \"must be enumerable\")\n        }\n        return true\n    },\n\n    /**\n     * @method notEnumerable\n     * @memberOf JFactoryExpect#\n     * @param {String} key\n     * @return JFactoryExpect\n     */\n    /**\n     * @method notEnumerable\n     * @memberOf JFactoryExpect\n     */\n    notEnumerable(label, value, key) {\n        if (Object.prototype.propertyIsEnumerable.call(value, key)) {\n            error(label, value, \"must not be enumerable\")\n        }\n        return true\n    },\n\n    /**\n     * @method configurable\n     * @memberOf JFactoryExpect#\n     * @param {String} key\n     * @return JFactoryExpect\n     */\n    /**\n     * @method configurable\n     * @memberOf JFactoryExpect\n     */\n    configurable(label, value, key) {\n        if (!Object.getOwnPropertyDescriptor(value, key).configurable) {\n            error(label, value, \"must be configurable\")\n        }\n        return true\n    },\n\n    /**\n     * @method notConfigurable\n     * @memberOf JFactoryExpect#\n     * @param {String} key\n     * @return JFactoryExpect\n     */\n    /**\n     * @method notConfigurable\n     * @memberOf JFactoryExpect\n     */\n    notConfigurable(label, value, key) {\n        if (Object.getOwnPropertyDescriptor(value, key).configurable) {\n            error(label, value, \"must not be configurable\")\n        }\n        return true\n    },\n\n    /**\n     * @method reservedProperty\n     * @memberOf JFactoryExpect#\n     * @param {String} key\n     * @return JFactoryExpect\n     */\n    /**\n     * @method reservedProperty\n     * @memberOf JFactoryExpect\n     */\n    reservedProperty(label, value, key) {\n        if (key in value) {\n            error(label, value, \"is a reserved property\")\n        }\n        return true\n    }\n};\n\njFactoryLoader.onInit(function() {\n    Object.assign(JFactoryExpect, staticMethods);\n    // Generate members from static methods\n    for (const name of Object.getOwnPropertyNames(staticMethods)) {\n        JFactoryExpect.prototype[name] =\n            function callStatic(...args) {\n                JFactoryExpect[name](this.label, this.value, ...args);\n                return this\n            }\n    }\n});","/* jFactory, Copyright (c) 2019, Stéphane Plazis, https://github.com/jfactory-es/jfactory/blob/master/LICENSE.txt */\n\nimport { JFACTORY_DEV } from \"./jFactory-env\";\nimport { JFactoryExpect } from \"./JFactoryExpect\";\nimport { jFactoryError } from \"./JFactoryError\";\nimport { jFactoryTrace } from \"./JFactoryTrace\";\nimport { jQuery, helper_isNative } from \"./jFactory-helpers\";\n\n// ---------------------------------------------------------------------------------------------------------------------\n// JFactoryPromise\n// ---------------------------------------------------------------------------------------------------------------------\n// Provides awaitable, expirable, debuggable promise chains\n// ---------------------------------------------------------------------------------------------------------------------\n// Status: Experimental Draft\n// ---------------------------------------------------------------------------------------------------------------------\n\n// #limitation# async functions always use the native Promise constructor even if native Promise class is overridden\n// #limitation# async functions always returns a native Promise even if returning an extended Promise\n// #limitation# async functions always returns a pending Promise even if returning a resolved Promise\n\nconst moduleGenId = () => ++moduleGenId.uid; moduleGenId.uid = 0;\n\n// ---------------------------------------------------------------------------------------------------------------------\n// JFactoryPromise\n// ---------------------------------------------------------------------------------------------------------------------\n\nexport class JFactoryPromise extends Promise {\n\n    constructor({ name, config, traceSource }, executor) {\n\n        if (arguments.length === 1) {\n            [name, config, executor] = [null, null, arguments[0]]\n        }\n\n        const chainId = moduleGenId();\n        config = { ...JFactoryPromise.DEFAULT_CONFIG, ...config };\n        name = name || \"unnamed\";\n\n        if (JFACTORY_DEV) {\n            JFactoryExpect(\"name\", name)\n                .type(String, Number)\n                .matchReg(/^[^. ]+$/);\n            JFactoryExpect(\"config\", config).typePlainObject();\n            JFactoryExpect(\"executor\", executor).typeFunction();\n        }\n\n        let resolve;\n        let reject;\n\n        super((_resolve, _reject) => {\n            resolve = _resolve;\n            reject = _reject;\n        });\n\n        const chain = new JFactoryPromiseChain(this, chainId, name, config);\n\n        Object.defineProperties(this, {\n            $chain: {\n                enumerable: true,\n                writable: true,\n                value: chain\n            },\n            $type: {\n                writable: true,\n                value: \"promise\"\n            },\n            $value: {\n                writable: true,\n                value: undefined\n            },\n            $isSettled: {\n                writable: true,\n                value: false\n            },\n            $isRejected: {\n                writable: true,\n                value: null\n            },\n            $isFulfilled: {\n                writable: true,\n                value: null\n            },\n            $isExpired: {\n                writable: true,\n                value: false\n            }\n        });\n\n        if (JFACTORY_DEV) {\n            Object.defineProperties(this, {\n                $dev_name: {\n                    configurable: true,\n                    value: name + \"[\" + chainId + \":0]\"\n                },\n                $dev_path: {\n                    writable: true,\n                    value: new JFactoryPromisePath(this)\n                },\n                $dev_position: {\n                    writable: true,\n                    value: 0\n                }\n            });\n            if (!helper_isNative(executor)) {\n                Object.defineProperties(this, {\n                    $dev_source: {\n                        value: executor\n                    }\n                });\n            }\n            jFactoryTrace.tracer.attachTrace(this, traceSource);\n        }\n\n        const tryAutoComplete = () => {\n            if (!this.$chain.isPending) {\n                try {\n                    this.$chainComplete(\"config.chainAutoComplete = true\");\n                } catch (e) {\n                    // Case of error in \"complete\" callback\n                    // We catch the exception because the promise is already fulfilled\n                    // Furthermore this issue must be handled by the chain, not the current promise\n                    console.error(e) // print the error otherwise nothing happens\n                }\n            }\n        };\n\n        const onResolve = value => {\n            // console.log('onResolve',this.$dev_name);\n            if (!this.$isSettled) {\n                // 2.3.1. If promise and x refer to the same object, reject promise with a TypeError as the reason.\n                if (value === this) {\n                    onReject(new TypeError(\"Chaining cycle detected for promise \" + this.$dev_name));\n                    return;\n                }\n\n                let then;\n                if (value !== null && (typeof value == \"object\" || typeof x == \"function\")) {\n                    // 2.3.3.2. If retrieving the property x.then results in a thrown exception e,\n                    // reject promise with e as the reason.\n                    try {\n                        then = value.then;\n                    } catch (e) {\n                        onReject(e);\n                        return;\n                    }\n                }\n\n                if (typeof then == \"function\") {\n                    let called = false;\n                    let resolvePromise = function(y) {\n                        // 2.3.3.3.1. If/when resolvePromise is called with a value y, run [[Resolve]](promise, y).\n                        if (!called) {\n                            called = true;\n                            onResolve(y);\n                        }\n                    };\n                    let rejectPromise = function(r) {\n                        // 2.3.3.3.2. If/when rejectPromise is called with a reason r, reject promise with r.\n                        if (!called) {\n                            called = true;\n                            onReject(r);\n                        }\n                    };\n\n                    try {\n                        then.call(value, resolvePromise, rejectPromise);\n                    } catch (e) { // 2.3.3.3.4. If calling then throws an exception e,\n                        // 2.3.3.3.4.1. If resolvePromise or rejectPromise have been called, ignore it.\n                        if (!called) {\n                            // 2.3.3.3.4.2. Otherwise, reject promise with e as the reason.\n                            onReject(e);\n                        }\n                    }\n                }\n                else {\n                    this.$isRejected = false;\n                    this.$isFulfilled = true;\n                    if (this.$isExpired) {\n                        value = this.$chain.errorExpired;\n                    }\n                    resolve(value);\n                    onSettle(value)\n                }\n            }\n        };\n\n        const onReject = reason => {\n            // console.log('onReject',this.$dev_name);\n            if (!this.$isSettled) {\n                this.$isRejected = true;\n                this.$isFulfilled = false;\n                reject(reason);\n                onSettle(reason)\n            }\n        };\n\n        const onSettle = value => {\n            this.$value = value;\n            this.$isSettled = true;\n            this.$chain.chainMap.set(this, true);\n\n            if (this.$chain.chainConfig.chainAutoComplete) {\n                if (this.$chain.chainMap.size === 1 && !this.$isExpired) {\n                    // ensures that tryAutoComplete() will be called asynchronously (then() callback is asynchronous)\n                    // case of promise.resolve(primitive), prevents following then() from being immediately locked\n                    this.then(tryAutoComplete)\n                } else {\n                    tryAutoComplete()\n                }\n            }\n        };\n\n        let _chainAutoComplete = config.chainAutoComplete;\n        Object.defineProperty(config, \"chainAutoComplete\", {\n            get: () => _chainAutoComplete,\n            set: value => {\n                if (_chainAutoComplete !== value) {\n                    _chainAutoComplete = value;\n                    if (value) {\n                        tryAutoComplete()\n                    }\n                }\n            }\n        });\n\n        chain.chainMap.set(this, false);\n\n        Object.defineProperties(this, {\n            __resolve__: {\n                value: onResolve\n            },\n            __reject__: {\n                value: onReject\n            }\n        });\n\n        try {\n            executor(onResolve, onReject);\n        } catch (e) {\n            onReject(e)\n        }\n    }\n\n    then(onFulfilled, onRejected, forceType) {\n        let wrappedFulfilled;\n        let wrappedRejected;\n        let newPromise;\n        let isNative = helper_isNative(onFulfilled) && !onFulfilled.name.startsWith(\"bound \");\n\n        if (onFulfilled && typeof onFulfilled === \"function\") {\n            wrappedFulfilled = function(r) {\n                // SPEC: \"await\" throws the errorExpired if expired\n                // Allows async function to try catch the awaited promise\n                // and allows stack call exit if not caught\n                if (type === \"await\" && newPromise.$isExpired === true && newPromise.$chain.errorExpired === r) {\n                    return onRejected(r)\n                }\n                if (!newPromise.$isSettled) {\n                    return onFulfilled(r)\n                }\n            }\n        }\n        if (onRejected && typeof onRejected === \"function\") {\n            wrappedRejected = function(r) {\n                if (!newPromise.$isSettled) {\n                    return onRejected(r)\n                }\n            }\n        }\n\n        let type = forceType || (isNative ? \"await\" : onFulfilled === undefined ? \"catch\" : \"then\");\n        newPromise = Object.assign(super.then(wrappedFulfilled, wrappedRejected), this);\n        moduleGenId.uid--; // reverse because not a new chain\n        newPromise.$type = type;\n\n        if (JFACTORY_DEV) {\n            newPromise.$dev_position = this.$chain.chainMap.size;\n            let fNames = \"\";\n            if (onFulfilled && onFulfilled.name) {\n                fNames += onFulfilled.name\n            }\n            if (onRejected && onRejected.name) {\n                fNames += \",\" + onRejected.name\n            }\n            Object.defineProperties(newPromise, {\n                $dev_name: {\n                    value:\n                        this.$chain.chainName\n                        + \"[\"\n                        + this.$chain.chainId\n                        + \":\"\n                        + this.$dev_position\n                        + \"]\"\n                        + \".\"\n                        + newPromise.$type\n                        + (fNames ? \"(\" + fNames + \")\" : \"\")\n                        + \"[\"\n                        + newPromise.$chain.chainId\n                        + \":\"\n                        + newPromise.$dev_position\n                        + \"]\"\n                },\n                $dev_path: { value: new JFactoryPromisePath(this.$dev_path, newPromise) },\n                $dev_onFulfilled: { value: onFulfilled },\n                $dev_onRejected: { value: onRejected }\n            });\n        }\n\n        newPromise.$chain.chainMap.set(newPromise, false);\n\n        if (this.$isExpired) {\n            // case: p0.then(); chainAbort(); p1.then()\n            // => the new promise must be expired\n            JFactoryPromise.forceExpire(newPromise, this.$chain.errorExpired)\n        }\n\n        return newPromise\n    }\n\n    $catchExpired(onExpired) {\n        return this.then(r => {\n            if (this.$chain.chainRoot.$isExpired) {\n                return onExpired(r)\n            } else {\n                return r\n            }\n        }, undefined, \"$catchExpired\")\n    }\n\n    static resolve(optionalArgs, value) {\n        // resolve()\n        // resolve(optionalArgs, value)\n        // resolve(value)\n\n        if (arguments.length === 1) {\n            [optionalArgs, value] = [{}, optionalArgs]\n        }\n        if (!optionalArgs) {\n            optionalArgs = {}\n        }\n        if (value instanceof this && arguments.length === 1) {\n            // Returns the promise as is (native spec)\n            // but only if no optionalArgs\n            return value\n        } else {\n            return new this(optionalArgs, function(resolve) {\n                resolve(value)\n            });\n        }\n    }\n\n    static reject(optionalArgs, reason) {\n        // reject()\n        // reject(optionalArgs, reason)\n        // reject(reason)\n\n        if (arguments.length === 1) {\n            [optionalArgs, reason] = [{}, optionalArgs]\n        }\n        if (!optionalArgs) {\n            optionalArgs = {}\n        }\n        return new this(optionalArgs, function(resolve, reject) {\n            reject(reason)\n        });\n    }\n\n    $toPromise() {\n        return Promise.resolve(this)\n    }\n\n    // Completes an expires the whole chain before its normal end\n    $chainAbort(reason = \"$chainAbort()\") {\n        this.$chain.complete(reason);\n        return this\n    }\n\n    // Manually completes an expires the whole chain\n    // Only required if awaiting \"myPromise.$chain\"\n    // when the autocomplete watcher is not used\n    $chainComplete(reason = \"$chainComplete()\") {\n        this.$chain.complete(reason);\n        return this\n    }\n\n    $chainAutoComplete() {\n        this.$chain.chainConfig.chainAutoComplete = true;\n        return this\n    }\n\n    static forceExpire(promise, reason) {\n        promise.$isExpired = true;\n        if (!promise.$isSettled) {\n            if (promise.$type !== \"await\" && promise.$type !== \"$catchExpired\") {\n                promise.__resolve__(reason)\n            }\n        }\n    }\n}\n\nJFactoryPromise.DEFAULT_CONFIG = {\n    chainAutoComplete: false\n};\n\n// ---------------------------------------------------------------------------------------------------------------------\n// JFactoryPromiseChain\n// ---------------------------------------------------------------------------------------------------------------------\n\nexport class JFactoryPromiseChain {\n\n    constructor(chainRoot, chainId, chainName, chainConfig) {\n        Object.defineProperties(this, {\n            chainConfig: { value: chainConfig },\n            chainRoot: { value: chainRoot },\n            chainId: { value: chainId },\n            chainName: { value: chainName },\n            chainMap: { value: new Map },\n            isCompleted: { value: false, configurable: true },\n            data: { value: {} },\n            // eslint-disable-next-line new-cap\n            __deferred__: { value: jQuery.Deferred() }\n        })\n    }\n\n    get isPending() {\n        return Array.from(this.chainMap.values()).includes(false)\n    }\n\n    then(onResolve) { // => \"await chain\"\n        this.__deferred__.done(onResolve);\n        return this\n    }\n\n    complete(reason = \"chain.complete()\") {\n        let chainRoot = this.chainRoot;\n        if (!chainRoot.$isExpired) {\n            let errorExpired = chainRoot.$chain.errorExpired = new jFactoryError.PROMISE_EXPIRED({\n                target: chainRoot,\n                reason\n            });\n\n            let map = this.chainMap;\n            for (let item of map.keys()) {\n                JFactoryPromise.forceExpire(item, errorExpired);\n            }\n\n            Object.defineProperty(this, \"isCompleted\", { value: true });\n            this.__deferred__.resolve();\n        }\n        return this\n    }\n}\n\n// ---------------------------------------------------------------------------------------------------------------------\n// JFactoryPromisePath\n// ---------------------------------------------------------------------------------------------------------------------\n\nexport class JFactoryPromisePath extends Array {\n\n    constructor() {\n        super();\n        for (let i of arguments) {\n            if (Array.isArray(i)) {\n                this.push(...i)\n            } else {\n                this.push(i)\n            }\n        }\n    }\n\n    get printable() {\n        return this.map((v, i) => i === 0 ? v.$dev_name : v.$dev_name.split(\".\")[1]).join(\".\")\n    }\n\n    toString() {return this.printable}\n}\n\n// ---------------------------------------------------------------------------------------------------------------------\n// JFactoryPromiseSync\n// ---------------------------------------------------------------------------------------------------------------------\n// Promise that tries to resolve synchronously\n// allowing synchronous states and result\n// ---------------------------------------------------------------------------------------------------------------------\n\nexport class JFactoryPromiseSync extends Promise {\n\n    constructor(executor) {\n\n        let states = {\n            $isSettled: false, // true = not pending\n            $isRejected: null, // true = not pending + rejected\n            $value: undefined\n        };\n\n        super((resolve, reject) => {\n\n            let called = false;\n\n            let onResolve = r => {\n                if (r instanceof Promise) {\n                    JFactoryPromiseSync.resolve(r)\n                        .then(onResolve, onReject)\n                } else {\n                    if (!called) {\n                        called = true;\n                        states.$isSettled = true;\n                        states.$isRejected = false;\n                        states.$value = r;\n                        resolve(r)\n                    }\n                }\n            };\n\n            let onReject = r => {\n                // don't resolve pending promise\n                // to keep native specification\n                if (!called) {\n                    called = true;\n                    states.$isSettled = true;\n                    states.$isRejected = true;\n                    states.$value = r;\n                    reject(r)\n                }\n            };\n\n            try {\n                executor(onResolve, onReject)\n            } catch (e) {\n                onReject(e)\n            }\n        });\n\n        Object.assign(this, states);\n        states = this\n    }\n\n    then(onFulfilled, onRejected) {\n\n        if (this.$isSettled) {\n            let value = this.$value;\n\n            try {\n                if (this.$isRejected) {\n                    // cancel any uncaught rejected result from this promise\n                    // before returning the new one\n                    super.then(undefined, () => null);\n\n                    if (onRejected && typeof onRejected === \"function\") {\n                        value = onRejected(value)\n                    } else {\n                        return JFactoryPromiseSync.reject(value)\n                    }\n                } else {\n                    if (onFulfilled && typeof onFulfilled === \"function\") {\n                        value = onFulfilled(value)\n                    }\n                }\n            } catch (e) {\n                return JFactoryPromiseSync.reject(e)\n            }\n\n            return JFactoryPromiseSync.resolve(value)\n\n        } else {\n            return super.then(onFulfilled, onRejected)\n        }\n    }\n\n    static resolve(value) {\n        if (value instanceof JFactoryPromiseSync) {\n            return value\n        } else {\n            if (value instanceof Promise) {\n                return new JFactoryPromiseSync(value.then.bind(value))\n            } else {\n                return new JFactoryPromiseSync(r => r(value))\n            }\n        }\n    }\n}"],"names":["JFACTORY_DEV","JFACTORY_CLI","process","versions","node","jFactoryConfig","TraitLog","JFactoryError","keys","JFactoryTrace","libOptions","offline","Boolean","globalThis","chrome","filter","value","lineNumber","jFactoryDev","requireCompatibility","test","info","fetch","Request","AbortController, AbortSignal","AbortController","signal","MutationObserver","jQuery","$","helper_isNative","_","isNative","helper_isString","isString","helper_isNumber","isNumber","helper_isPlainObject","isPlainObject","helper_lowerFirst","lowerFirst","helper_get","get","helper_template","template","NOOP","jFactoryLoader","seq","[object Object]","this","module","jFactoryOverride","handler","push","onInit","console","warn","name","entry","Object","entries","pass","ignore","JFactoryTrace_NOFILTER","label","stackTraceLimit","Infinity","omitAboveFunctionName","omitSelf","_stackTraceLimit","Error","traceSource","source","targetObject","captureTraceSource","trace","toPrintableTrace","then","r","log","defineProperty","enumerable","configurable","Promise","resolve","JFactoryTrace_LIB_STACKTRACE","config","super","StackTrace","fromError","traceFrames","slice","findIndex","functionName","endsWith","formatTraceFrames","header","linePrefix","window","map","sf","toString","join","jFactoryTrace","use","constructor","tracer","attachTrace","message","data","assign","create","toPrintable","$data","Symbol","iterator","object","DEFAULT_KEYS","find","key","val","templateData","nv","undefined","getId","JSON","stringify","length","JSON_MAX","substring","e","String","templateMessage","part","split","placeholder","RE_PLACEHOLDER","lastIndex","exec","trim","toPrintableData","jFactoryError","Proxy","set","target","property","prototype","JFactoryExpect","INVALID_VALUE","INVALID_CALL","PROMISE_EXPIRED","REQUEST_ERROR","KEY_DUPLICATED","KEY_MISSING","error","reason","given","staticMethods","notUndefined","notEmptyString","notFalsy","validSpaces","replace","matchReg","reg","expected","ok","typeNull","typeBoolean","typeString","typeNumber","typeFunction","typePlainObject","equalIn","Array","isArray","values","includes","getOwnPropertyNames","writable","getOwnPropertyDescriptor","notWritable","propertyIsEnumerable","call","notEnumerable","notConfigurable","reservedProperty","args","moduleGenId","uid","JFactoryPromise","executor","arguments","chainId","reject","DEFAULT_CONFIG","type","Number","_resolve","_reject","chain","JFactoryPromiseChain","defineProperties","$chain","$type","$value","$isSettled","$isRejected","$isFulfilled","$isExpired","$dev_name","$dev_path","JFactoryPromisePath","$dev_position","$dev_source","tryAutoComplete","isPending","$chainComplete","onResolve","onReject","TypeError","x","called","resolvePromise","y","rejectPromise","errorExpired","onSettle","chainMap","chainConfig","chainAutoComplete","size","_chainAutoComplete","__resolve__","__reject__","onFulfilled","onRejected","forceType","wrappedFulfilled","wrappedRejected","newPromise","startsWith","fNames","chainName","$dev_onFulfilled","$dev_onRejected","forceExpire","onExpired","chainRoot","optionalArgs","complete","promise","Map","isCompleted","__deferred__","Deferred","from","done","item","i","printable","v"],"mappings":"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"}